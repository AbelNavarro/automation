#!/usr/bin/env python

import contextlib
import glob
import json
import os
import re
import shutil
import sys
import tempfile
import time

import requests

import sh

DEPENDS_ON_RE = re.compile(r"^Depends-On: (I[0-9a-f]{40})\s*$",
                           re.MULTILINE | re.IGNORECASE)

def project_map():
    map_file = os.path.join(os.path.dirname(__file__), 'project-map.json')
    with open(map_file) as map:
        project_map = json.load(map)
    return project_map


@contextlib.contextmanager
def cd(dir):
    pwd = os.getcwd()
    try:
        os.chdir(dir)
        yield
    finally:
        os.chdir(pwd)


class GerritChange:

    GERRIT = 'https://gerrit.suse.provo.cloud'

    def __init__(self, change_id):
        self.id = change_id
        query_url = '%(gerrit)s/changes/%(change_id)s/' % {
            'gerrit': self.GERRIT, 'change_id': self.id}
        query_url += '?o=CURRENT_REVISION&o=CURRENT_COMMIT'
        print("Retrieving change %s" % change_id)
        response = requests.get(query_url)
        print("Got response: %s" % response)
        self._change_object = json.loads(response.text.replace(")]}'", ''))
        self.change_id = self._change_object['change_id']
        self.project = self._change_object['project'].split('/')[1]
        current_revision = self._change_object['current_revision']
        revision_obj = self._change_object['revisions'][current_revision]
        self.url = revision_obj['fetch']['anonymous http']['url']
        self.ref = revision_obj['fetch']['anonymous http']['ref']
        self.target = self._change_object['branch']
        self.subject = revision_obj['commit']['subject']
        self.commit_message = revision_obj['commit']['message']

    def get_depends_on_changes(self):
        # For now only check this change's depends-on
        # This will miss any depends-on on commits between the supplied ones
        # and the branch.
        return DEPENDS_ON_RE.findall(self.commit_message)

    def prep_workspace(self):
        if not os.path.exists('./source'):
            os.mkdir('source')
        with cd('source'):
            if not os.path.exists('%s.git/.git' % self.project):
                print("Cloning project %s" % self.project)
                sh.git('clone', self.url, '%s.git' % self.project)
            with cd('%s.git' % self.project):
                # If another change is already checked out on this branch,
                # don't clobber it.
                try:
                    sh.git('checkout', 'test-merge')
                except sh.ErrorReturnCode_1:
                    sh.git('checkout', '-b', 'test-merge', self.target)
                print("Fetching ref %s" % self.ref)
                sh.git('fetch', self.url, self.ref)
                sh.git('merge', '--no-edit', 'FETCH_HEAD')


def test_project_name(change_ids, homeproject):
    return '%s:ardana-ci-%s' % (homeproject, '-'.join(change_ids))


def create_test_project(develproject, testproject, repository):
    repo_metadata = """
<project name="%(testproject)s">
  <title>Autogenerated CI project</title>
  <description/>
  <link project="%(develproject)s"/>
  <person userid="opensuseapibmw" role="maintainer"/>
  <publish>
    <enable repository="standard"/>
  </publish>
  <repository name="standard" rebuild="direct" block="local"
      linkedbuild="localdep">
    <path project="%(develproject)s" repository="%(repository)s"/>
    <arch>x86_64</arch>
  </repository>
</project>
""" % {'testproject': testproject,
       'develproject': develproject,
       'repository': repository}

    with tempfile.NamedTemporaryFile() as meta:
        meta.write(repo_metadata)
        meta.flush()
        print("Creating test project %s linked to devel project %s" %
              (testproject, develproject))
        sh.osc('-A', 'https://api.suse.de', 'api', '-T', meta.name,
               '/source/%s/_meta' % testproject)


def wait_for_build(project, testproject):
    package_name = project_map()[project]
    print("Waiting for %s to build" % package_name)
    with cd('%s/%s' % (testproject, package_name)):
        while 'unknown' in sh.osc('results'):
            print("Waiting for build to be scheduled")
            time.sleep(3)
        print("Waiting for build results")
        for attempt in range(3):
            results = sh.osc('results', '--watch')
            print("Build results: %s" % results)
            if 'broken' in results:
                # Sometimes results --watch ends too soon, give it a few
                # retries before actually failing
                print("Sleeping for 10s before rechecking")
                time.sleep(10)
                continue
            else:
                break
        if 'succeeded' not in results:
            print("Package build failed.")
            sys.exit(1)


def create_test_package(project, develproject, testproject):
    package_name = project_map()[project]
    print("Creating test package %s" % package_name)
    sh.osc('-A', 'https://api.suse.de', 'copypac', '--keep-link',
           develproject, package_name, testproject)
    sh.osc('-A', 'https://api.suse.de', 'checkout', testproject, package_name)
    source_dir = '%s/source/%s.git' % (os.getcwd(), project)
    with cd('%s/%s' % (testproject, package_name)):
        with open('_service', 'r+') as service_file:
            service_def = service_file.read()
            service_def = re.sub(r'<param name="url">.*</param>',
                                 '<param name="url">%s</param>' % source_dir,
                                 service_def)
            service_def = re.sub(r'<param name="revision">.*</param>',
                                 '<param name="revision">test-merge</param>',
                                 service_def)
            service_file.seek(0)
            service_file.write(service_def)
            service_file.truncate()
        sh.osc('rm', glob.glob('%s*.obscpio' % package_name))
        sh.osc('service', 'disabledrun')
        sh.osc('add', glob.glob('%s*.obscpio' % package_name))
        sh.osc('commit', '-m', 'Testing changes from %s' % testproject)


def cleanup(testproject):
    if os.path.exists('./source'):
        shutil.rmtree('./source')
    if os.path.exists('./%s' % testproject):
        shutil.rmtree('./%s' % testproject)


def main(change_ids, develproject, homeproject, repository):
    testproject = test_project_name(change_ids, homeproject)
    cleanup(testproject)
    create_test_project(develproject, testproject, repository)

    # Changes is dict of 'gerrit_id': GerritChange.
    changes = {}
    # Keep track of the list of projects to finally build
    projects = set()
    # Grab the changes
    for id in change_ids:
        if id in changes:
            # Duplicate dependency, skipping..
            continue
        c = GerritChange(id)
        changes[c.change_id] = c
        projects.add(c.project)
        dependent_changes = c.get_depends_on_changes()
        change_ids.extend(dependent_changes)

    for change in changes.values():
        # This merges the particular gerrit change into the workspace
        change.prep_workspace()

    for project in projects:
        create_test_package(project, develproject, testproject)

    # Check all packages are built
    # NOTE(jhesketh): this could be optimised to check packages in parallel,
    # however the worst case scenario at the moment is
    # "time for longest package" + "time for num_of_package checks" which isn't
    # too much more than the minimum
    # ("time for longest package" + "time for one check")
    for project in projects:
        wait_for_build(project,  testproject)

    cleanup(testproject)


if __name__ == '__main__':
    change_ids = os.environ['gerrit_change_ids'].split(',')
    develproject = os.environ['develproject']
    homeproject = os.environ['homeproject']
    repository = os.environ['repository']

    main(change_ids, develproject, homeproject, repository)
